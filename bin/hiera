#!/usr/bin/env ruby

# CLI client for Hiera.
#
# To lookup the 'release' key for a node given Puppet YAML facts:
#
# $ hiera release 'rel/%{location}' --yaml some.node.yaml
#
# If the node yaml had a location fact the default would match that
# else you can supply scope values on the command line
#
# $ hiera release 'rel/%{location}' location=dc2 --yaml some.node.yaml

# Bundler and rubygems maintain a set of directories from which to
# load gems. If Bundler is loaded, let it determine what can be
# loaded. If it's not loaded, then use rubygems. But do this before
# loading any hiera code, so that our gem loading system is sane.
if not defined? ::Bundler
  begin
    require 'rubygems'
  rescue LoadError
  end
end
require 'hiera'
require 'optparse'
require 'json'

options = {
  :default => nil,
  :config  => '/etc/hiera/hiera.yaml',
  :scope   => {},
  :key     => nil,
  :verbose => false,
  :resolution_type => :priority
}

OptionParser.new do |opts|
  opts.banner = "Usage: hiera [options] key [default value] [variable='text'...]\n\nThe default value will be used if no value is found for the key. Scope variables\nwill be interpolated into %{variable} placeholders in the hierarchy and in\nreturned values.\n\n"

  opts.on("--version", "-V", "Version information") do
    puts Hiera.version
    exit
  end

  opts.on("--debug", "-d", "Show debugging information") do
    options[:verbose] = true
  end

  opts.on("--array", "-a", "Return all values as an array") do
    options[:resolution_type] = :array
  end

  opts.on("--hash", "-h", "Return all values as a hash") do
    options[:resolution_type] = :hash
  end

  opts.on("--config CONFIG", "-c", "Configuration file") do |v|
    if File.exist?(v)
      options[:config] = v
    else
      STDERR.puts "Cannot find config file: #{v}"
      exit 1
    end
  end

  opts.on("--json SCOPE", "-j", "JSON format file to load scope from") do |source|
    begin
      unless File.exist?(source)
        STDERR.puts "Cannot find scope JSON file #{source}"
        exit 1
      end

      scope = JSON.load(File.read(source))

      unless scope.is_a?(Hash)
        STDERR.puts "Scope from JSON file #{source} must be a Hash"
        exit 1
      end

      options[:scope] = scope
    rescue Exception => e
      STDERR.puts "Could not load JSON scope: #{e.class}: #{e}"
      exit 1
    end
  end
end.parse!

if ARGV.empty?
  STDERR.puts "Please supply a data item to look up"
  exit 1
else
  # arguments can be:
  #
  # key default var=val another=val
  #
  # The var=val's assign scope
  options[:key] = ARGV.delete_at(0)

  ARGV.each do |arg|
    if arg =~ /^(.+?)=(.+?)$/
      options[:scope][$1] = $2
    else
      unless options[:default]
        options[:default] = arg.dup
      else
        STDERR.puts "Don't know how to parse scope argument: #{arg}"
      end
    end
  end
end

begin
  config = Hiera::Config.load(options[:config])
rescue Exception => e
  STDERR.puts "Failed to start Hiera: #{e.class}: #{e}"
  exit 1
end

data = Hiera::Interpolation.new(options[:scope])
hierarchy = config.hierarchy(data)
p hierarchy.lookup(options[:key], options[:resolution_type]).otherwise(options[:default])
